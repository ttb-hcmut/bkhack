# Reduced motions

The UI components of BKHack exhibits animations such as fading in / out of colors when hover. These animations take a transition duration of 300ms. Animations provide a modern, natural feel to our application. However, due to accessibility reasons, it's not always preferrable to have animations; things should be instantaneously snappy sometimes.

For CSS, all rules that define `transition`-related properties must have their duals when `@media (prefers-reduced-motion)`

> This was motivated when one of the developers (kinten)'s desktop environment (GNOME) uses reduced motion

# Multi-page bundling

Web applications adopt one of these paradigms:

- Multi-page application (MPA)
- Single-page application (SPA)

BKHack adopts a hybrid paradigm. At its core, it's MPA. But within a webpage there can be some "subpages", "subviews", which don't require a request to server to navigate to.

The adoption of this paradigm has been somewhat troublesome. Most build tools support either MPA or SPA, not inbetween. For example, the Webpack bundler accepts a JavaScript entry point and outputs a single main bundle file intended for the entire website: this is SPA; so is the Webpack dev-server. Our build system involves in-house OCaml programming plus some hacking of Webpack: specifically, we spawn multiple Webpack instances to make multiple JS bundles corresponding to each route; and we abandon Webpack dev-server altogether in favor of our custom dev-server built on top of live-server.

# Icon graphics, and how the website renders

There are two encodings[^jfp]:

1. The initial encoding. Prefer textual elements
2. The final encoding. Prefer graphical elements

For example, (TBA)

The final encoding is enabled by the `data-tileset` attribute at the root element. To render the site in its initial encoding form, open the Inspector and unset `data-tileset` to anything other than the value `gui`.

> Our limited build system is what motivated this two-encoding workflow in the first place!

There are various techniques for implementing this two-encoding workflow. At its core is the decoupling of static assets from HTML. Conventionally you would declare assets in HTML or React JSX as img or svg elements. For our workflow, assets are declared in CSS. For CSS rules, you can embed images as background images of elements or pseudo-elements.

# Some notes on bundling and asset management

All static asset - html document, css stylesheet, icon svg - should be separated into files. This is opposite to the inline philosophy e.g. inline styling, css-in-js, etc.

> Inspired by DHH's No Build paradigm. We split / distribute the application into as many file modules as possible, because modern browsers can handle multiple file modules very efficiently (compared to the bundle-based approach)

It'd be nice to have a Reason abstraction for importing static assets. Currently, asset management is manual, requires programmable pipeline, and thus error-prone.

[^jfp]: totally has nothing to do with initial vs. final encoding from theory of algebraic specification
