# Reduced motions [^reduced]

The UI components of BKHack exhibits animations such as fading in / out of colors when hover. These animations take a transition duration of 200ms. Animations provide a modern, natural feel to our application. However, due to accessibility reasons, it's not always preferrable to have animations; things should be instantaneously snappy sometimes.

For CSS, all rules that define `transition`-related properties must have their duals when `@media (prefers-reduced-motion)`

> This was motivated when one of the developers (kinten)'s desktop environment (GNOME) uses reduced motion

# Multi-page bundling

Web applications adopt one of these paradigms:

- Multi-page application (MPA)
- Single-page application (SPA)

BKHack adopts a hybrid paradigm. At its core, it's MPA. But within a webpage there can be some "subpages", "subviews", which don't require a request to server to navigate to.

TODO(kinten): insert diagram here

The adoption of this paradigm has been somewhat troublesome. Most build tools support either MPA or SPA, not inbetween. For example, the Webpack bundler accepts a JavaScript entry point and outputs a single main bundle file intended for the entire website: this is SPA; so is the Webpack dev-server. Our build system involves in-house OCaml programming plus some hacking of Webpack: specifically, we spawn multiple Webpack instances to make multiple JS bundles corresponding to each route; and we abandon Webpack dev-server altogether in favor of our custom dev-server built on top of live-server.

# Icon graphics, and how the website renders [^icon]

There are two encodings[^jfp]:

1. The initial encoding. Prefer textual elements
2. The final encoding. Prefer graphical elements

For example, TODO(kinten): insert example graphics here

The final encoding is enabled by the `data-tileset` attribute at the root element. To render the site in its initial encoding form, open the Inspector and unset `data-tileset` to anything other than the value `gui`.

> Our limited build system is what motivated this two-encoding workflow in the first place!

There are various techniques for implementing this two-encoding workflow. At its core is the decoupling of static assets from HTML. Conventionally you would declare assets in HTML or React JSX as img or svg elements. For our workflow, assets are declared in CSS. For CSS rules, you can embed images as background images of elements or pseudo-elements.

# Some notes on bundling and asset management

All static asset - html document, css stylesheet, icon svg - should be separated into files. This is opposite to the inline philosophy e.g. inline styling, css-in-js, etc.

> Inspired by DHH's No Build paradigm. We split / distribute the application into as many file modules as possible, because modern browsers can handle multiple file modules very efficiently (compared to the bundle-based approach)

It'd be nice to have a Reason abstraction for importing static assets. Currently, asset management is manual, requires programmable pipeline, and thus error-prone.

[^jfp]: totally has nothing to do with initial vs. final encoding from theory of algebraic specification

# Style layering

0. CSS reset
1. The initial encoding
2. Reduced-motion encoding (see [^reduced])
3. The final (graphical) encoding (see [^icon])
4. The light mode encoding
5. CSS User-agent (Arc themes, GNOME Web Custom JS/CSS, Tampermonkey extension for Chrome and Firefox)

# Build system and file attributes

For our current build system, our philosophy is to distribute configurations as much as possible. Avoid the phenomenon where we need a bunch of centralized `.rc` files or `jsconfig` files or a dictionary in a script file, etc.

We need to inform the build system that for a Reason page file $ x $ there is a mapping to a JavaScript bundle $ y $ at a url $ y' $. In early versions, I (kinten) tested using a dictionary placed in the script file to define this mapping. In newer versions, I have decided to utilized Reason's infile floating attributes [^attributes] in each Reason page file. This is a native way to provide decorator-like metadata to a file / module unit.

```reason
[@Bkhack.page "/item"]
// rest of file
```

[^attributes]: https://ocaml.org/manual/5.3/attributes.html

> One of the most definitive use cases of floating attributes! The OCamldoc system also support floating attributes for manipulating system.
